1/17
[ ] multiple selection
[x] edit static layer
[-] input focusing / common hotkeys
[ ] event system w/ subscription
[x] hide -> vis, hide reveal
[x] Compile field offsets using literals

1/18
[ ] scale or resize anything with the mouse, smooth or snapped

SHED context menu:
[ ] grouping/ungrouping
[ ] push selected to object
[ ] bring-to-front, send-to-back

1/19
[x] if needed, add tasks

1/20
[ ] aed shouldn't be moving timelines
    some kind of proxy object

1/21
[ ] PRIVATE and PUBLIC
    PRIVATE automatically creates a wordlist with the name of the current file
    to be used with FGET ?
    the wordlists automatically add themselves to the search order
    to reset the search order, ONLY FORTH or maybe a shorthand
[x] Update shed.txt, ui.txt (rename to repl.txt),
[ ] There are some issues related to serializing and replacement
    Stale references - solve by never reassigning, only replacing? 
    But then there is the issue of children
    One solution is to make all references (i.e. name-words) work like variables (i.e. you have to @ from them),
        then we can reassign without worry
    Replacement *is* possible, because we're only reusing the memory slot, not
        preserving tree structure.  <--- THIS IS THE RIGHT WAY OF THINKING ABOUT IT
    This will be built into NAME which will copy the entire source slot to the destination slot,
        removing all the destination's children - but not yet freeing them, because there might be
        some named slots there!  So we put them in a temporary list ...
    The only caveat with this is if the original object is referenced before NAMED or NAME is called on it,
        it becomes a stale reference...
        