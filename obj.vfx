\ - Object stack
: bpage here $ff and 256 swap - allot here $100 allot constant ;
bpage os
variable osp  os osp !
: >o osp @ ! 4 osp c+! ;
: o> -4 osp c+! osp @ @ ;

\ - Structs
: field create over , + does> @ + ;

\ - Addressing
0 value me
: as to me ;
: { me >o to me ;
: } o> to me ;
: -> ' >body @ ?literal s" +" evaluate ; immediate 
: require me { require } ;
: include me { include } ;
: included me { included } ;

\ - Vars
0 value /obj
0 value /basis
: ofield /obj swap field to /obj does> @ me + ;
: var cell ofield ;
: motif /basis to /obj ;

\ - Double-linked tree
var next var prev var first var last var parent
include lib/dltree.vfx
: remove dlremove ;
: push dlpush ;
: unshift dlunshift ;
: insert dlinsert ;
: each dleach ;
: (each>) r> swap dleach ;
: each> postpone (each>) discard-sinline ; immediate
: clear dlclear ;

\ - Basis
var en var hide var halt var nam 
var x var y var w var h var vx var vy var sx var sy
var beh var drw var phy
/obj to /basis
defer children

\ - Naming support
: $create-name $create , does> @ ;
: name ( obj $ - )
    find if
        2dup >name swap -> nam !
        over swap >body @ !
    else
        over swap $create-name latest ctrl>nfa over -> nam !
    then ;
: named bl word name ;
: .name -> nam @ ?dup if count type space then ;
    
\ - Instancing
: init en on 1. dup sx v! ;
: *child here 256 allot&erase dup rot push dup { init }  ;
: obj  here as 256 allot&erase init  me value  latest ctrl>nfa nam ! ;

\ - Basic actions
: reckon
    first @ {  begin  me while
        next @ >r
            recurse
            en @ 0= if me remove  then
        r> as
    repeat }
;
: ?execute ?dup 0; catch dup .throw if quit then ;
: +t +m x v@ 2i 2p>f sx v@ 2p>f 0e transform ;
: -t -m ;
: ?children first @ if +t children -t then ;
: draw en @ 0; hide @ ?; drw @ ?dup if +t 0 0 at ?execute children -t else ?children then ; 
:noname [ is children ] first @ 0; ['] draw me each ;
: act halt @ ?;  en @ 0;  beh @ ?execute  me each>  recurse ;
: physics halt @ ?;  en @ 0;  phy @ ?execute  me each>  recurse ;
: (draw>) r> drw ! ; : draw> postpone (draw>) discard-sinline ; immediate
: (act>) r> beh ! ; : act> postpone (act>) discard-sinline ; immediate

\ - Indexed child access
: #children 0 swap -> first @ ?dup 0; begin 1 u+ -> next @ ?dup 0= until ;
: nth-child -> first @ dup 0= if nip exit then swap 0 ?do -> next @ loop ;
