\ - Object stack
: bpage here $ff and 256 swap - allot here $100 allot constant ;
bpage os
variable osp  os osp !
: >o osp @ ! 4 osp c+! ;
: o> -4 osp c+! osp @ @ ;

\ - Structs
: field create over , + does> @ + ;

\ - Addressing
0 value me
: as to me ;
: { me >o to me ;
: } o> to me ;
: -> ' >body @ ?literal s" +" evaluate ; immediate 
: require me { require } ;
: include me { include } ;
: included me { included } ;

\ - Vars
0 value /obj
0 value /basis
: ofield /obj swap field to /obj does> @ me + ;
: var cell ofield ;
: motif /basis to /obj ;

\ - Double-linked tree
var en var next var prev var first var last var parent
include lib/dltree.vfx
: remove dlremove ;
: push dlpush ;
: unshift dlunshift ;
: insert-after dlinsert-after ;
: each dleach ;
: (each>) r> swap dleach ;
: each> postpone (each>) discard-sinline ; immediate
: clear dlclear ;
: insert 2dup 2>r insert-after 2r> swap insert-after ;

\ - Basis
var nam
/obj constant /linkage
var dead var vis var halt var con 
var x var y var w var h var vx var vy var sx var sy
var beh var drw var phy
/obj to /basis
defer children

\ - Naming support
: reference create 0 , does> @ ; 
: $create-name $create , does> @ ;
: name ( obj $ - )
    find if
        cr ." REASSIGN: "
        2dup >name dup count type swap -> nam !
        udup >body !
    else
        udup $create-name latest ctrl>nfa over -> nam !
    then ;
: named bl word name ;
: .name -> nam @ ?dup if count type space then ;

\ - Instancing
defer 1object
:noname [ is 1object ] con ! pen v@ 2s>p x v! ;
: init en on vis on 1. dup sx v! ;
: *slot here 256 allot&erase ;
: *child ( parent - obj ) *slot dup rot push dup { init }  ;
: object:
    create here 0 , :noname swap !
    does> me *child { dup body> 1object @ execute me } ;    
object: *generic ;
: obj reference  *slot as  init  ['] *generic con !  latest-xt  me over >body !  >name nam ! ;

\ - Basic actions
: kill { en off dead on } ;
: reckon
    first @ {  begin  me while
        next @ >r
            recurse
            dead @ if me remove then
        r> as
    repeat }
;
: ?execute ?dup 0; catch dup .throw if quit then ;
: +t +m x v@ 2i 2p>f sx v@ 2p>f 0e transform ;
: -t -m ;
: ?children first @ if +t children -t then ;
: draw en @ 0; vis @ 0; drw @ ?dup if +t 0 0 at ?execute children -t else ?children then ; 
:noname [ is children ] first @ 0; ['] draw me each ;
: act halt @ ?;  en @ 0;  beh @ ?execute  me each>  recurse ;
: physics halt @ ?;  en @ 0;  phy @ ?execute  me each>  recurse ;
: (draw>) r> drw ! ; : draw> postpone (draw>) discard-sinline ; immediate
: (act>) r> beh ! ; : act> postpone (act>) discard-sinline ; immediate

\ - Indexed child access
: #children 0 swap -> first @ ?dup 0; begin 1 u+ -> next @ ?dup 0= until ;
: nth-child -> first @ dup 0= if nip exit then swap 0 ?do -> next @ loop ;
