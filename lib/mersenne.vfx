require lib/counter.vfx

1 constant tinymt32-sh0
10 constant tinymt32-sh1
8 constant tinymt32-sh8
$7FFFFFFF constant tinymt32-mask

struct tinymt32-size
    4 cells +field tinymt32-status
    field: tinymt32-mat1
    field: tinymt32-mat2
    field: tinymt32-tmat
end-struct

\ This function changes internal state of tinymt32.
\ Users should not call this function directly.
: tinymt32-next-state ( random -- )
    >r ( )
    3 cells r@ tinymt32-status + @ ( y )
    0 cells r@ tinymt32-status + @ tinymt32-mask and ( y s0-masked )
    1 cells r@ tinymt32-status + @ xor ( y s0^s1 )
    2 cells r@ tinymt32-status + @ xor ( y x )
    dup tinymt32-sh0 lshift xor ( y x )
    swap dup tinymt32-sh0 rshift 2 pick xor xor ( x y )
    1 cells r@ tinymt32-status + @ ( x y s1 )
    0 cells r@ tinymt32-status + ! ( x y )
    2 cells r@ tinymt32-status + @ ( x y s2 )
    1 cells r@ tinymt32-status + ! ( x y )
    tuck tinymt32-sh1 lshift xor 2 cells r@ tinymt32-status + ! ( y )
    dup 3 cells r@ tinymt32-status + ! ( y )
    dup 1 and negate r@ tinymt32-mat1 @ and ( y a )
    swap 1 and negate r@ tinymt32-mat2 @ and ( a b )
    2 cells r@ tinymt32-status + @ ( a b s2 )
    xor 2 cells r@ tinymt32-status + ! ( a )
    1 cells r@ tinymt32-status + @ ( a s1 )
    xor 1 cells r> tinymt32-status + ! ( )
;

\ This function outputs 32-bit unsigned integer from internal state.
\ Users should not call tihs function directly.
: tinymt32-temper ( random -- x )
    >r
    3 cells r@ tinymt32-status + @ ( t0 )
    0 cells r@ tinymt32-status + @ ( t0 s0 )
    2 cells r@ tinymt32-status + @ tinymt32-sh8 rshift + ( t0 t1 )
    tuck xor ( t1 t0 )
    swap 1 and if ( t0 )
        r> tinymt32-tmat @ xor ( t0 )
    else
        r> drop ( t0 )
    then
;

8 constant min-loop
8 constant pre-loop

\ This function certificate the period of 2^127-1
: period-certification ( random -- )
    >r ( )
    0 cells r@ tinymt32-status + @ tinymt32-mask and 0=
    1 cells r@ tinymt32-status + @ 0= and
    2 cells r@ tinymt32-status + @ 0= and
    3 cells r@ tinymt32-status + @ 0= and if
        [char] T 0 cells r@ tinymt32-status + !
        [char] I 1 cells r@ tinymt32-status + !
        [char] N 2 cells r@ tinymt32-status + !
        [char] Y 3 cells r> tinymt32-status + !
    else
        r> drop
    then
;

\ This function initializes the internal state array with a 32-bit unsigned
\ integer seed.
: tinymt32-init ( seed random -- )
    >r ( seed )
    0 cells r@ tinymt32-status + ! ( )
    r@ tinymt32-mat1 @ 1 cells r@ tinymt32-status + ! ( )
    r@ tinymt32-mat2 @ 2 cells r@ tinymt32-status + ! ( )
    r@ tinymt32-tmat @ 3 cells r@ tinymt32-status + ! ( )
    1 begin dup min-loop < while ( i )
        dup 3 and cells r@ tinymt32-status + @ ( i x )
        1812433253 ( i x constant )
        2 pick 1- 3 and cells r@ tinymt32-status + @ ( i x constant y )
        dup 30 rshift xor * 2 pick + xor ( i z )
        over 3 and cells r@ tinymt32-status + ! ( i )
    1+ repeat drop ( )
    r@ period-certification ( )
    0 begin dup pre-loop < while r@ tinymt32-next-state 1+ repeat drop ( )
    r> drop ( )
;

\ Prepare the internal state's mat1, mat2, and tmat values
: tinymt32-prepare ( mat1 mat2 tmat random -- )
    >r ( mat1 mat2 tmat )
    r@ tinymt32-tmat ! ( mat1 mat2 )
    r@ tinymt32-mat2 ! ( mat1 )
    r> tinymt32-mat1 ! ( )
;

\ Example internal state values
: tinymt32-prep ( random -- )
    >r counter $8F7011EE + dup $FC78FF1F + dup $3793FDFF + r> tinymt32-prepare
;

\ This function outputs 32-bit unsigned integer from internal state.
: tinymt32-generate-uint32 ( random -- x )
    dup tinymt32-next-state tinymt32-temper
;

create mersenne tinymt32-size allot&erase
mersenne tinymt32-init
mersenne tinymt32-prep
: ?abs abs over 0< if negate then ;
: rnd mersenne tinymt32-generate-uint32 ?abs swap mod ;
