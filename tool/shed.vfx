require lib/filetypes.vfx

0 value dragee
0 value this
0 value hoveree
variable snapping
\ 0 value always-drag?

1 bit bolted_ bit locked_ value _attributes

\ - Game config
: matte x v@ 2p>s gamew zoom sf* gameh zoom sf* al_set_clipping_rectangle ;
: center
    winw 2 /  gamew zoom sf* 2 / -
    winh 64 - 2 /  gameh zoom sf* 2 / -  2s>p game -> x v!
    zoom f>p dup game -> sx v!
;
: game-act act> center zoom f>p dup sx v! draw> matte ;
c: *game game-act ;
game as game-act ' *game con !

\ - Scripting
motif var ser var attr var post /obj to /basis
: (physics>) r> phy ! ;
: physics> postpone (physics>) discard-sinline ; immediate
:noname [ is 1object ] con ! pen v@ 2s>p x v! physics> vx v@ 2delta* x v+! ;
: copy *slot { me 256 move  linkage erase  me } ;
: (*clone) ( orig new ) | p |
    -> first @ begin ?dup while
        dup dup copy dup p push
        recurse
        -> next @
    repeat ;
: clone dup copy dup >r (*clone) r> ;
: a? attr @ and 0<> ;
: aoff invert attr @ and attr ! ;
: aon attr @ or attr ! ;
: replace dup >r insert r> kill ;
: from -> x v@ p>s at ;
: a+t
    +m identity
    me begin ?dup while
        dup { x v@ 2p>f  sx v@ 2p>f } 0e
            m2 al_build_transform  m m2 al_compose_transform
        -> parent @
    repeat
    m al_use_transform
;
: ascale/ parent @ ?dup if { recurse } then sx v@ 2p/ ;
: ascale* sx v@ 2p* parent @ ?dup if { recurse } then ;
: abox a+t 0 0 v*m w v@ ascale* area -t ;
: >local abox 2drop 2- ascale/ ;
: s>local 2s>p >local 2p>s ;
: hide -> vis off ;
: reveal -> vis on ;

\ - Definition
: [locked] locked_ aon ;
: [bolted] bolted_ aon ;

\ - Stage
game {
    *generic named stage { }
}

\ - Quickly reload a set file
create reload$ 64 allot
: reload cr ." ==================== RELOAD ====================" reload$ count included ;
s" shed.vfx" reload$ place
: fget 0 parse reload$ place s" .vfx" reload$ append reload$ count included ;

\ - Dragging
: +drag bolted_ a? ?; walt 2s>p ascale/ sx v@ 2p* x v+! ;
: dragging alt? if workspace else dragee then ?dup 0; { +drag } ;
: tsnap dup abs 8. + dup 16. mod - swap 0< if negate then ;
: ?snap x v@ snapping @ if tsnap swap tsnap swap else 2i then x v! ;
: plop alt? if workspace else dragee then ?dup 0; { ?snap } 0 to dragee ;
: m*box x v@ w v@ sx v@ 2p* area v*m 2swap v*m 2swap ;
: (hovering) me each> vis @ 0; w v@ or 0<> first @ or 0; 
    mouse 2s>p m*box inside? if me to hoveree then +t recurse -t ;
: hovering { 0 to hoveree +t (hovering) -t } ;
: pick to this ;
: drag to dragee ;

\ - Serialize
variable indent
: +i  4 indent +! ;
: -i  -4 indent +! ;
: cri cr indent @ 0 ?do space loop ;
: .xy x v@ 2p>s swap . . ;
: ?.en en @ 0= if ." en off " then ;
: ?.vis vis @ 0= if ." vis off " then ;
: ?.halt halt @ if ." halt on " then ;
: ?.a attr @ ?dup if h. ." attr ! " then ; \ <- could be more future-proof
: ?.wh w v@ or if w vp? ." w v! " then ;
: ?.s sx v@ or 1. <> if sx vp? ." sx v! " then ;
: .con con @ ?dup if >name count type space else ." *GENERIC " then ;
: .{ ." { " ;
: .} ." } " } ;
: .}r first @ if cri then .} ;
: ?.named nam @ if ." named " me .name then ;
: (o.) .xy ." at " .con ?.named .{ ?.en ?.vis ?.halt ?.a ?.wh ?.s ;
: o. { (o.) .} ;
: o.c { (o.) ['] .}r >r me each> cr ."     " me o. ;
: o.r cri { (o.) ser @ ?execute space ['] .}r >r me each> +i me recurse -i ;
: osave >r dup -> nam @ count r> name>path 2dup 2>r f[ o.r ]f cr ." Saved to " 2r> type ;
: save ' execute figpath osave ;
: oload 2dup type me { included } me -> last @ ;
: ?existing find if execute else drop 0 then ;
: ?replace ?dup 0; dup -> parent @ 0= if ."  orphan " drop dup remove exit then udup replace ;
: postload post @ ?dup if count evaluate then me each> recurse ;
: load bl word dup ?existing >r count figpath name>path oload r> ?replace as postload me pick ;
: ser> r> ser ! ;
: post: here aligned post ! 0 parse $, ;

\ - Info
: stext @color >r 1 1 +at dup black text -1 -1 +at r> color text ;
: tiny a+t 0 0 v*m 2p>s at -t identity ;
: (info) +m tiny 0 -33 +at sherry32.fnt font ! z[ me o. ]z stext -m ;
: outline a+t 0 0 at w v@ 2p>s rect -t ;

\ - UI extension
: ?drag ( obj - ) 1 mheld? if drop dragging else hovering then ;
: outlines
    hoveree ?dup if { yellow outline } then
    this ?dup if { red outline (info) } then
;

: +zoom
    workspace { 
    0.25 * sx @ dup >r + 0.25 2. clamp dup sx v!
    mouse 2s>p >local sx v@ 2p* 1. sx @ r> p/ - dup  2p*  x v+!
    } ;

: ?locked dup { locked_ a? } 0; drop cr ." Object is locked. Cannot delete!" r> drop ;
: unpick 0 pick 0 drag 0 to hoveree ;
: delete ?dup 0; ?locked kill unpick workspace { reckon } ;
: shed-respond
    respond>
    ALLEGRO_EVENT_KEY_DOWN happened? if
        the-key <f5> = if s" reload" evaluate exit then
    then
    editmode @ if
        ALLEGRO_EVENT_KEY_DOWN happened? if
            the-key <del> = if this delete then
        then
    then
    ALLEGRO_EVENT_KEY_CHAR happened? if
        this 0;
        the-key case
        endcase
    then            
    ALLEGRO_EVENT_MOUSE_BUTTON_DOWN happened? if
        hoveree ?dup if dup pick drag then
    then
    ALLEGRO_EVENT_MOUSE_BUTTON_UP happened?
    ALLEGRO_EVENT_DISPLAY_SWITCH_OUT happened? or if
        plop
    then
    ALLEGRO_EVENT_MOUSE_AXES happened? if
        e MOUSE_EVENT.dz @ ?dup if +zoom then
    then
; 

c: *shed shed-respond act> workspace ?drag draw> -matte ;
c: *info draw> editmode @ 0; outlines ;

workspace {
    *shed named shed {
        *generic named tools { }
        *info named info { }
    }
}
