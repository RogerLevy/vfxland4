display 1920 2 / 0 al_set_window_position
vfx-hwnd 0 0 0 0 0 $41 SetWindowPos drop

0 value stage
0 value dragee
0 value this
0 value hoveree
variable snapping

motif var constructor var ax var ay var ser /obj to /basis

\ - Gradient
create gv  4 /ALLEGRO_VERTEX * allot&erase
create gi  0 , 1 , 2 , 3 ,
: 2sf f>ds f>ds swap ;
: vpos! ( x y a n ) /ALLEGRO_VERTEX * + >r  2s>f 2sf  r> v! ;
: vcolor! ( a-color a n )  /ALLEGRO_VERTEX * + >r  4f@  r> ALLEGRO_VERTEX.r 4f! ;
: gradient
    at@ 2+ at@ | y x y2 x2 c2 c1 | 
    x y gv 0 vpos!  x2 y gv 1 vpos!  x2 y2 gv 2 vpos!  x y2 gv 3 vpos!
    c1 gv 2dup 0 vcolor! 1 vcolor!  c2 gv 2dup 2 vcolor! 3 vcolor!
    gv 0 0 gi 4 ALLEGRO_PRIM_TRIANGLE_FAN al_draw_indexed_prim ;

\ - Scripting
: *one you *child as ;
: physics> r> phy ! ;
: (*actor) *one constructor ! physics> vx v@ 2delta* x v+! ;
: *actor here postpone literal postpone (*actor) ; immediate  
: kill -> en off ;
: *stage *actor me to stage ;
viewport { *stage }

\ - Quickly reload a set file
create reload$ 64 allot
: reload cr ." ==================== RELOAD ====================" reload$ count included ;
s" shed.vfx" reload$ place
: fget 0 parse reload$ place s" .vfx" reload$ append reload$ count included ;

\ - Dragging
: zoom/ >r zoom sf/ r> zoom sf/ ;
: +drag walt 2s>p zoom/ x v+! ;
: dragging alt? if stage else dragee then { +drag } ;
: tsnap 8. + dup 16. mod - ;
: ?snap snapping @ if tsnap swap tsnap swap else 2i then ;
: stop-dragging alt? if stage else dragee then ?dup 0; { x v@ ?snap x v! } 0 to dragee ;
: (hovering) me each> mouse 2s>p zoom/ ax v@ w v@ area inside? if me to hoveree then  recurse ;
: hovering 0 to hoveree (hovering) ;
: pick to this ;
: drag to dragee ;

\ - UI extensions
: echar e KEYBOARD_EVENT.unichar @ ;
: ekey e KEYBOARD_EVENT.keycode @ ;
: ?delete this ?dup 0; kill 0 pick 0 drag 0 to hoveree root { reckon } ;
:noname [ is app-events ]
    ALLEGRO_EVENT_DISPLAY_SWITCH_IN happened? if
    then
    ALLEGRO_EVENT_KEY_DOWN happened? if
        ekey <f5> = if s" reload" evaluate then
        ekey <f3> = if viewport { halt @ invert halt ! } then
        ekey <del> = if ?delete then
    then
    ALLEGRO_EVENT_MOUSE_BUTTON_DOWN happened? if
        hoveree ?dup if dup pick drag then
    then
    ALLEGRO_EVENT_MOUSE_BUTTON_UP happened? if
        stop-dragging
    then
;

\ - Serialize
variable indent
: +i  4 indent +! ;
: -i  -4 indent +! ;
: cri cr indent @ 0 ?do space loop ;
: .xy x v@ 2p>s swap . . ;
: ?.wh w v@ or if w vp? ." w v! " then ;
: .constructor constructor @ >name count type space ;
: o. { .xy ." at " .constructor ?.wh } ser @ ?execute space ;
: .{ first @ if ." me {" then ;
: .} first @ if cri ." }" then ;
: o.r constructor @ if cri dup o. then .{ ['] .} >r each> +i me recurse -i ;
: figpath z[ ." figures/" type ." .vfx" ]z zcount ;
: save figpath f[ viewport o.r ]f ;
: save-to 0 parse save ;
: load 0 pick viewport clear viewport { 0 parse figpath included } ;
: ser> r> ser ! ;

\ - Info
: stext @color >r 1 1 +at dup black text -1 -1 +at r> color text ;
: outline ax v@ 2p>s at w v@ 2p>s rect ;
: zoom* >r zoom sf* r> zoom sf* ;
: tiny identity pen v@ zoom* at ;
: info 0 -16 zoom/ 1 - +at +m tiny z[ me o. ]z stext -m ;

: !positions parent @ ?dup if -> ax v@ x v@ 2+ ax v!  then  me each> recurse ;

\ - UI extension
obj shed
uiext clear
shed uiext push
:noname
    act>
        root { !positions }
        dragee alt? 1 mheld? and or if dragging else root { hovering } then
    draw>
        +m identity 0e 0e zoom fdup 0e transform
        hoveree ?dup if { yellow outline } then
        this ?dup if { green outline info } then
        -m
; execute
